<div class="blog-item-text"  :class="{'mobile': window.width <=1023}">
    <p>Меня зовут Иван, я разработчик в фирме ОСЬМИНОЖКА. Через нас проходит много проектов и оценок, функционал там повторяется, поэтому я решил показать, как мы решаем типовые задачи, и поделиться этим с вами. Начнем мы с самого начала. Как правило, началом для приложений служит авторизация. Рассмотрим классический случай с вводом номера телефона и смской и остановимся подробнее на экране подтверждения смс.</p>
    <p>Выглядит не очень сложно, но, если присмотреться, функционал экрана довольно большой, а именно:</p>
    <p>отправить код на сервер;<br />включить таймер повторной отправки + отобразить визуально;<br />после завершения таймера показать кнопку «отправить еще раз»;<br />отправить повторный запрос на получение кода;<br />отобразить все ошибки;<br />обработать успешное подтверждение кода.<br />Если попробовать разделить экран на UI и логику, получается примерно такое взаимодействие между логикой и интерфейсом.</p>
    <img src="img/image.png" width="100%" alt="">
    <p class="dark">
        Можно, конечно, отправить всю логику про таймеры и isLoading на view слой, но мне больше нравится относить это к логике. Особенно учитывая то, что я большой поклонник MVVM+Rx (и буду это использовать в статье), это более чем уместно смотрится. Ну да ладно.
    </p>
    <p class="dark">
        ViewModel в этом случае играет роль некоего «преобразователя» пользовательских действий: у нее есть input и output(видно на картинке выше).
    </p>
    <p class="dark">
        Со стороны UI нам будут интересны следующие компоненты:
    </p>
    <div class="code">
        <code>
final class ConfirmCodeViewController: BaseViewController {
    /// поле ввода кода private lazy var codeTextField = CodeTextField()
    /// лейбл для отображения ошибок private lazy var errorLabel = UILabel()

    /// один лоадер для запросов на отправку кода и на повторный запрос кода private lazy var loader = UIActivityIndicatorView()

    /// лейбл с обратным отсчетом для повторной отправки кода private lazy var timerLabel = UILabel()

    /// кнопка повторной отправки кода private lazy var retryButton = UIButton(type: .system)

    /// это все будет в стеквью private lazy var stackView = UIStackView()}  
        </code>
    </div>
    <p class="dark">
        Можно, конечно, отправить всю логику про таймеры и isLoading на view слой, но мне больше нравится относить это к логике. Особенно учитывая то, что я большой поклонник MVVM+Rx (и буду это использовать в статье), это более чем уместно смотрится. Ну да ладно.
    </p>
    <p class="dark">
        ViewModel в этом случае играет роль некоего «преобразователя» пользовательских действий: у нее есть input и output(видно на картинке выше).
    </p>
    <p class="dark">
        Со стороны UI нам будут интересны следующие компоненты:
    </p>
    <div class="code">
<code>final class ConfirmCodeViewController: BaseViewController {
    /// поле ввода кода private lazy var codeTextField = CodeTextField()
    /// лейбл для отображения ошибок private lazy var errorLabel = UILabel()

    /// один лоадер для запросов на отправку кода и на повторный запрос кода private lazy var loader = UIActivityIndicatorView()

    /// лейбл с обратным отсчетом для повторной отправки кода private lazy var timerLabel = UILabel()

    /// кнопка повторной отправки кода private lazy var retryButton = UIButton(type: .system)

    /// это все будет в стеквью private lazy var stackView = UIStackView()}</code>
    </div>
</div>